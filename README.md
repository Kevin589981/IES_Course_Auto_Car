这是电导小车项目

项目需要多线程，考虑到项目复杂度，是否直接所有变量都是全局变量？

# 检测色彩 # 实时运行，多线程锁
编写detect_color.py
传入参数为一张图片（图片格式类型需要统一好）
1. 先截取图片的特定行，减少运算量（行号写在py文件开头方便后续修改）
2. HSV变换
3. 测定好不同颜色的HSR值，并设定阈值
4. 遍历所有像素点，统计红、橙、黄、蓝、绿出现的位置
5. 函数返回格式：待定
？一种可能的返回格式式：返回一个字典{
    "red": [(x1, x2,(x1+x2)/2),(x'1,x'2,(x'1+x'2)/2),...] # 使用元组提高效率，分别是该颜色像素的横坐标开始、结束、中间（以画面中点为标准x=0处）
}
如果该颜色不存在则字典not ("color" in 字典名)

PS： 4/30.23:56标定函数已完成，初步标定结果在json文件中，可能需要进一步优化标定结果

# 超声测距编写 # 实时运行，多线程锁
# TODO
编写detect_distance.py



## 小车运动逻辑

```python
state = 1
state_color = {}

while(True):
    if (state == 1):
        # first time detect and write color
        # do state 1 for 1 step
        if (if_state_1_done):
            state = 2
    else if (state == 2)
    	# ...
```



### 一、单个魔方（state 1和state3）

1. 先直走，直到看到单个魔方，检测并记录颜色（不妨假设不会受到后续魔方干扰）（为了保证识别正确，建议连续检测3次结果一样再进行后续操作）
   1. state 1依靠手动放置，确保魔方在视野内，识别的是宽度最大的那个
   2. state 3开始前，先左转90度，再右转180度（大概即可），找到目标魔方（理应只有最后一个）
2. 持续检测这个颜色的魔方的距离
   1. 当距离小于最小阈值时，判断是否会碰撞：如果会则倒车，不会则直行
   2. 当距离大于最小阈值时，根据颜色逻辑执行（第3点）
3. 根据当前魔方颜色和左/右边缘的x值，设定一个虚拟的目标点
   1. 以黄色/红色为例，瞄准左边缘左侧固定像素点为目标，即x1-d，d为一个固定值（可以根据实际情况调整）
   2. 以蓝色/绿色为例，瞄准右边缘右侧固定像素点为目标，即x2+d，d为一个固定值（可以根据实际情况调整）
4. 在通过魔方之后，继续直行一段时间（注意不能太大，这个时间可以手动调参数）



### 二、两个魔方（state 2）

1. 原地旋转，直到看到两个同色的魔方，检测并记录颜色
2. 持续检测这个颜色的魔方的距离
   1. 当距离小于最小阈值时，判断是否会碰撞：如果会则倒车，不会则直行
   2. 当距离大于最小阈值时，根据颜色逻辑执行
3. 根据当前两个魔方的左/右边缘x值，瞄准x12与x21的中点


新的思路：
3个阶段中每个阶段，都直接怼着魔方跑，第一个、第三个阶段，看到魔方